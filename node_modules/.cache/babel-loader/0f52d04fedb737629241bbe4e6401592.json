{"ast":null,"code":"\"use strict\";\n\nvar fs = require('fs');\n\nvar mime = require('mime-types');\n\nvar errorStrings = require('./../lib/error');\n\nmodule.exports = IssueClient;\n/**\r\n * Used to access Jira REST endpoints in '/rest/api/2/issue' and '/rest/agile/1.0/issue'\r\n * @constructor IssueClient\r\n * @param {JiraClient} jiraClient\r\n */\n\nfunction IssueClient(jiraClient) {\n  this.jiraClient = jiraClient;\n  /**\r\n   * Returns the estimation of the issue and a filedId of the field that is\r\n   * used for it.  The boardId parameter is required, and determines which\r\n   * field will be updated on an issue.\r\n   *\r\n   * @method getIssueEstimation\r\n   * @memberOf IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this\r\n   *        object must contain EITHER an issueId or issueKey property;\r\n   *        issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {string} [opts.boardId] The id of the board required to\r\n   *        determine which field is used for estimation.\r\n   * @param [callback] Called when the issue estimation has been retrieved.\r\n   * @return {Promise} Resolved when the issue estimation has been retrieved.\r\n   */\n\n  this.getIssueEstimation = function (opts, callback) {\n    var endpoint = '/issue/' + (opts.issueId || opts.issueKey) + '/estimation';\n    var options = {\n      uri: this.jiraClient.buildAgileURL(endpoint),\n      method: 'GET',\n      json: true,\n      followAllRedirects: true,\n      qs: {\n        boardId: opts.boardId,\n        filter: opts.filter,\n        startAt: opts.startAt,\n        maxResults: opts.maxResults\n      }\n    };\n    return this.jiraClient.makeRequest(options, callback);\n  };\n  /**\r\n   * Updates the estimation of the issue.  The boardId parameter is required,\r\n   * and determines which field will be updated on an issue.\r\n   *\r\n   * @method setIssueEstimation\r\n   * @memberOf IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this\r\n   *        object must contain EITHER an issueId or issueKey property;\r\n   *        issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.value] The value to set the issue estimation as.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of teh issue.  EX: JWR-3\r\n   * @param {string} [opts.boardId] The id of the board required to\r\n   *        determine which field is used for estimation.\r\n   * @param [callback] Called when the issue estimation has been created.\r\n   * @return {Promise} Resolved when the issue estimation has been created.\r\n   */\n\n\n  this.setIssueEstimation = function (opts, callback) {\n    var endpoint = '/issue/' + (opts.issueId || opts.issueKey) + '/estimation';\n    var options = {\n      uri: this.jiraClient.buildAgileURL(endpoint),\n      method: 'PUT',\n      json: true,\n      followAllRedirects: true,\n      body: {\n        value: opts.value,\n        filter: opts.filter,\n        startAt: opts.startAt,\n        maxResults: opts.maxResults\n      },\n      qs: {\n        boardId: opts.boardId\n      }\n    };\n    return this.jiraClient.makeRequest(options, callback);\n  };\n  /**\r\n   * Moves (ranks) issues before or after a given issue.\r\n   *\r\n   * @method setIssueRanks\r\n   * @memberOf IssueClient#\r\n   * @param {Object} ranking The ranking data in the form of PUT body to the\r\n   *        Jira API.\r\n   * @param [callback] Called when the issue rank has been created.\r\n   * @return {Promise} Resolved when the issue rank has been created.\r\n   */\n\n\n  this.setIssueRanks = function (ranking, callback) {\n    var options = {\n      uri: this.jiraClient.buildAgileURL('/issue/rank'),\n      method: 'PUT',\n      json: true,\n      followAllRedirects: true,\n      body: ranking\n    };\n    return this.jiraClient.makeRequest(options, callback);\n  };\n  /**\r\n   * Creates an issue or a sub-task from a JSON representation.\r\n   *\r\n   * The fields that can be set on create, in either the fields parameter or the update parameter can be determined\r\n   * using the /rest/api/2/issue/createmeta resource. If a field is not configured to appear on the create screen,\r\n   * then it will not be in the createmeta, and a field validation error will occur if it is submitted.\r\n   *\r\n   * Creating a sub-task is similar to creating a regular issue, with two important differences:\r\n   *\r\n   * * the issueType field must correspond to a sub-task issue type (you can use /issue/createmeta to discover\r\n   * sub-task issue types), and\r\n   * * you must provide a parent field in the issue create request containing the id or key of the parent issue.\r\n   *\r\n   * @method createIssue\r\n   * @memberof IssueClient#\r\n   * @param {Object} issue The issue data in the form of POST body to the JIRA API.\r\n   * See {@link https://docs.atlassian.com/jira/REST/latest/#d2e398}\r\n   * @param [callback] Called when the issue has been created.\r\n   * @return {Promise} Resolved when the issue has been created.\r\n   */\n\n\n  this.createIssue = function (issue, callback) {\n    var options = {\n      uri: this.jiraClient.buildURL('/issue'),\n      method: 'POST',\n      followAllRedirects: true,\n      json: true,\n      body: issue\n    };\n    return this.jiraClient.makeRequest(options, callback);\n  };\n  /**\r\n   * Returns the meta data for creating issues. This includes the available projects, issue types and fields,\r\n   * including field types and whether or not those fields are required. Projects will not be returned if the user\r\n   * does not have permission to create issues in that project.\r\n   *\r\n   * The fields in the createmeta correspond to the fields in the create screen for the project/issuetype. Fields not\r\n   * in the screen will not be in the createmeta.\r\n   *\r\n   * Fields will only be returned if ```expand=projects.issuetypes.fields.```\r\n   *\r\n   * The results can be filtered by project and/or issue type, given by the query params.\r\n   *\r\n   * @method getCreateMetadata\r\n   * @memberOf IssueClient#\r\n   * @param {Object} [opts] The options for the API request.\r\n   * @param {string} [opts.projectIds] combined with the projectKeys param, lists the projects with which to filter\r\n   *     the results. If absent, all projects are returned. This parameter can be specified multiple times, and/or be\r\n   *     a comma-separated list. Specifiying a project that does not exist (or that you cannot create issues in) is\r\n   *     not an error, but it will not be in the results.\r\n   * @param {string} [opts.projectKeys] combined with the projectIds param, lists the projects with which to filter\r\n   *     the results. If null, all projects are returned. This parameter can be specified multiple times, and/or be a\r\n   *     comma-separated list. Specifiying a project that does not exist (or that you cannot create issues in) is not\r\n   *     an error, but it will not be in the results.\r\n   * @param {string} [opts.issuetypeIds] combinded with issuetypeNames, lists the issue types with which to filter\r\n   *     the results. If null, all issue types are returned. This parameter can be specified multiple times, and/or\r\n   *     be a comma-separated list. Specifiying an issue type that does not exist is not an error.\r\n   * @param {string} [opts.issuetypeNames] combinded with issuetypeIds, lists the issue types with which to filter\r\n   *     the results. If null, all issue types are returned. This parameter can be specified multiple times, but is\r\n   *     NOT interpreted as a comma-separated list. Specifiying an issue type that does not exist is not an error.\r\n   * @param {string} [opts.expand] in order to get expanded field descriptions, specify 'projects.issuetypes.fields' here.\r\n   * @param [callback] Called when the metadata has been retrieved.\r\n   * @return {Promise} Resolved when the metadata has been retrieved.\r\n   */\n\n\n  this.getCreateMetadata = function (opts, callback) {\n    var options = {\n      uri: this.jiraClient.buildURL('/issue/createmeta'),\n      method: 'GET',\n      followAllRedirects: true,\n      json: true,\n      qs: {\n        projectIds: opts.projectIds,\n        projectKeys: opts.projectKeys,\n        issuetypeIds: opts.issuetypeIds,\n        issuetypeNames: opts.issuetypeNames,\n        expand: opts.expand\n      }\n    };\n    return this.jiraClient.makeRequest(options, callback);\n  };\n  /**\r\n   * Creates issues or sub-tasks from a JSON representation.\r\n   *\r\n   * Creates many issues in one bulk operation.\r\n   *\r\n   * Creating a sub-task is similar to creating a regular issue. More details can be found in createIssue section:\r\n   * {@link IssueResource#createIssue(IssueUpdateBean)}}\r\n   *\r\n   * @method bulkCreate\r\n   * @memberof IssueClient#\r\n   * @param issues See {@link https://docs.atlassian.com/jira/REST/latest/#d2e828}\r\n   * @param [callback] Called when the issues have been created.\r\n   * @return {Promise} Resolved when the issues have been created.\r\n   */\n\n\n  this.bulkCreate = function (issues, callback) {\n    var options = {\n      uri: this.jiraClient.buildURL('/issue/bulk'),\n      method: 'POST',\n      followAllRedirects: true,\n      json: true,\n      body: issues\n    };\n    return this.jiraClient.makeRequest(options, callback);\n  };\n  /**\r\n   * Returns a full representation of the issue for the given issue key.\r\n   *\r\n   * An issue JSON consists of the issue key, a collection of fields, a link to the workflow transition sub-resource,\r\n   * and (optionally) the HTML rendered values of any fields that support it (e.g. if wiki syntax is enabled for the\r\n   * description or comments).\r\n   *\r\n   * The fields param (which can be specified multiple times) gives a comma-separated list of fields to include in\r\n   * the response. This can be used to retrieve a subset of fields. A particular field can be excluded by prefixing\r\n   * it with a minus.\r\n   *\r\n   * By default, all (\\*all) fields are returned in this get-issue resource. Note: the default is different when doing\r\n   * a jql search -- the default there is just navigable fields (\\*navigable).\r\n   *\r\n   * * \\*all - include all fields\r\n   * * \\*navigable - include just navigable fields\r\n   * * summary,comment - include just the summary and comments\r\n   * * -comment - include everything except comments (the default is *all for get-issue)\r\n   * * \\*all,-comment - include everything except comments\r\n   *\r\n   * JIRA will attempt to identify the issue by the issueIdOrKey path parameter. This can be an issue id, or an issue\r\n   * key. If the issue cannot be found via an exact match, JIRA will also look for the issue in a case-insensitive\r\n   * way, or by looking to see if the issue was moved. In either of these cases, the request will proceed as normal\r\n   * (a 302 or other redirect will not be returned). The issue key contained in the response will indicate the\r\n   * current value of issue's key.\r\n   *\r\n   * @method getIssue\r\n   * @memberof IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *        issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {boolean} [opts.agile] Whether or not to call the agile version of this endpoint.  Defaults to false.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {Object} [opts.fields] See {@link https://docs.atlassian.com/jira/REST/latest/#d2e611}\r\n   * @param {Object} [opts.expand] See {@link https://docs.atlassian.com/jira/REST/latest/#d2e611}\r\n   * @param {Object} [opts.properties] See {@link https://docs.atlassian.com/jira/REST/latest/#d2e611}\r\n   * @param [callback] Called when data has been retrieved\r\n   * @return {Promise} Resolved when data has been retrieved\r\n   */\n\n\n  this.getIssue = function (opts, callback) {\n    if (!opts.agile) {\n      var options = this.buildRequestOptions(opts, '', 'GET');\n    } else {\n      var endpoint = '/issue/' + (opts.issueId || opts.issueKey);\n      var options = {\n        uri: this.jiraClient.buildAgileURL(endpoint),\n        method: 'GET',\n        json: true,\n        followAllRedirects: true,\n        qs: {\n          filter: opts.filter,\n          startAt: opts.startAt,\n          maxResults: opts.maxResults,\n          expand: opts.expand\n        }\n      };\n    }\n\n    return this.jiraClient.makeRequest(options, callback);\n  };\n  /**\r\n   * Delete an issue. If the issue has subtasks you must set the parameter deleteSubtasks=true to delete the issue.\r\n   * You cannot delete an issue without its subtasks also being deleted.\r\n   *\r\n   * @method deleteIssue\r\n   * @memberof IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *        issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {string} [opts.deleteSubtasks] \"a String of true or false indicating that any subtasks should also\r\n   *        be deleted. If the issue has no subtasks this parameter is ignored. If the issue has subtasks and this\r\n   *        parameter is missing or false, then the issue will not be deleted and an error will be returned.\"\r\n   * @param [callback] Called when data has been retrieved\r\n   * @return {Promise} Resolved when data has been retrieved\r\n   */\n\n\n  this.deleteIssue = function (opts, callback) {\n    var options = this.buildRequestOptions(opts, '', 'DELETE', null, {\n      deleteSubtasks: opts.deleteSubtasks\n    });\n    return this.jiraClient.makeRequest(options, callback, 'Issue Deleted');\n  };\n  /**\r\n   *  Edits an issue from a JSON representation.\r\n   *\r\n   * The issue can either be updated by setting explicit the field value(s) or by using an operation to change the\r\n   * field value.\r\n   *\r\n   * The fields that can be updated, in either the fields parameter or the update parameter, can be determined using\r\n   * the {@link IssueClient#getEditMetadata} method. If a field is not configured to appear on the edit\r\n   * screen, then it will not be in the editmeta, and a field validation error will occur if it is submitted.\r\n   *\r\n   * Specifying a \"field_id\": field_value in the \"fields\" is a shorthand for a \"set\" operation in the \"update\"\r\n   * section. Field should appear either in \"fields\" or \"update\", not in both.\r\n   *\r\n   * @method editIssue\r\n   * @memberof IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *        issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {boolean} [opts.notifyUsers]\r\n   * @param {boolean} [opts.overrideScreenSecurity]\r\n   * @param {boolean} [opts.overrideEditableFlag]\r\n   * @param {Object} [opts.issue] See {@link https://docs.atlassian.com/jira/REST/latest/#d2e656}\r\n   * @param {Object} [opts.issue.transition]\r\n   * @param {Object} [opts.issue.fields]\r\n   * @param {Object} [opts.issue.update]\r\n   * @param {Object} [opts.issue.historyMetadata]\r\n   * @param {Object} [opts.issue.properties]\r\n   * @param {callback} [callback] Called when data has been retrieved\r\n   * @return {Promise} Resolved when data has been retrieved\r\n   */\n\n\n  this.editIssue = function (opts, callback) {\n    var options = {\n      uri: this.jiraClient.buildURL('/issue/' + (opts.issueId || opts.issueKey)),\n      method: 'PUT',\n      json: true,\n      followAllRedirects: true,\n      qs: Object.assign({}, opts, {\n        issueKey: undefined,\n        issueId: undefined,\n        issue: undefined\n      }),\n      body: opts.issue || opts.body\n    };\n    return this.jiraClient.makeRequest(options, callback, 'Issue Updated');\n  };\n  /**\r\n   * Assigns an issue to a user. You can use this resource to assign issues when the user submitting the request has\r\n   * the assign permission but not the edit issue permission. If the name is \"-1\" automatic assignee is used. A null\r\n   * name will remove the assignee. or\r\n   * You can use accountId of the user whom to assign the issue.\r\n   * See {@link https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/}\r\n   * @method assignIssue\r\n   * @memberof IssueClient#\r\n   * @param {Object} opts use assignee name or accountId to assign the issue \r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {string} [opts.assignee] The name of the user to whom to assign the issue\r\n   * @param {string} [opts.accountId] The accountId of the user to whom to assign the issue. -1 for default, null for no assignee.\r\n   * @param [callback] Called when the issue has been assigned.\r\n   * @return {Promise} Resolved when the issue has been assigned.\r\n   */\n\n\n  this.assignIssue = function (opts, callback) {\n    var assigneeIdOrName = opts.accountId || opts.assignee;\n\n    if (!(typeof assigneeIdOrName === \"string\" && assigneeIdOrName.length || assigneeIdOrName === null)) {\n      throw new Error(errorStrings.NO_ASSIGNEE_ERROR);\n    }\n\n    var params = opts.accountId ? {\n      accountId: opts.accountId\n    } : {\n      name: opts.assignee\n    };\n    var options = this.buildRequestOptions(opts, '/assignee', 'PUT', params);\n    return this.jiraClient.makeRequest(options, callback, 'Issue Assigned');\n  };\n  /**\r\n   * Get all the comments for an issue.\r\n   *\r\n   * @method getComments\r\n   * @memberof IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *        issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {Object} opts.expand See {@link https://docs.atlassian.com/jira/REST/latest/#d2e461}\r\n   * @param [callback] Called when the issue has been assigned.\r\n   * @return {Promise} Resolved when the issue has been assigned.\r\n   */\n\n\n  this.getComments = function (opts, callback) {\n    var options = this.buildRequestOptions(opts, '/comment', 'GET');\n    return this.jiraClient.makeRequest(options, callback);\n  };\n  /**\r\n   * Add a comment to an issue\r\n   *\r\n   * @method addComment\r\n   * @memberof IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *        issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {string} [opts.expand] Use expand to include additional information about comments\r\n   * in the response. This parameter accepts renderedBody, which returns the comment body rendered in HTML.\r\n   * @param {string} [opts.body] The comment text\r\n   * @param {string} [opts.visibility] The group or role to which this comment is visible. Optional on create and update.\r\n   * @param {string} [opts.properties] A list of comment properties. Optional on create and update.\r\n   * @param {callback} [callback] Called when data has been retrieved\r\n   * @return {Promise} Resolved when data has been retrieved\r\n   */\n\n\n  this.addComment = function (opts, callback) {\n    var options = {\n      uri: this.jiraClient.buildURL('/issue/' + (opts.issueId || opts.issueKey) + '/comment'),\n      method: 'POST',\n      json: true,\n      followAllRedirects: true,\n      qs: {\n        expand: opts.expand\n      },\n      body: Object.assign({\n        body: opts.body || opts.comment,\n        // backward compatibility (opts.comment should be removed in next major version)\n        visibility: opts.visibility,\n        properties: opts.properties\n      }, opts, {\n        expand: undefined,\n        comment: undefined,\n        issueId: undefined,\n        issueKey: undefined\n      })\n    };\n    return this.jiraClient.makeRequest(options, callback);\n  };\n  /**\r\n   * Get a specific comment.\r\n   *\r\n   * @method getComment\r\n   * @memberof IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *        issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {string} opts.commentId The id of the comment.\r\n   * @param [callback] Called when the comment is retrieved.\r\n   * @return {Promise} Resolved when the comment is retrieved.\r\n   */\n\n\n  this.getComment = function (opts, callback) {\n    if (!opts.commentId) {\n      throw new Error(errorStrings.NO_COMMENT_ID);\n    }\n\n    var options = this.buildRequestOptions(opts, '/comment/' + opts.commentId, 'GET');\n    return this.jiraClient.makeRequest(options, callback);\n  };\n  /**\r\n   * Updates an existing comment using its JSON representation.\r\n   *\r\n   * @method editComment\r\n   * @memberof IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *        issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {string} opts.commentId The id of the comment.\r\n   * @param {Object} opts.comment See {@link https://docs.atlassian.com/jira/REST/latest/#d2e539}\r\n   * @param [callback] Called when data has been retrieved\r\n   * @return {Promise} Resolved when data has been retrieved\r\n   */\n\n\n  this.editComment = function (opts, callback) {\n    if (!opts.comment) {\n      throw new Error(errorStrings.NO_COMMENT_ERROR);\n    } else if (!opts.commentId) {\n      throw new Error(errorStrings.NO_COMMENT_ID);\n    }\n\n    var options = this.buildRequestOptions(opts, '/comment/' + opts.commentId, 'PUT', opts.comment);\n    return this.jiraClient.makeRequest(options, callback);\n  };\n  /**\r\n   * Delete an existing comment.\r\n   *\r\n   * @method deleteComment\r\n   * @memberof IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *        issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {string} opts.commentId The id of the comment.\r\n   * @param [callback] Called when the comment is retrieved.\r\n   * @return {Promise} Resolved when the comment is retrieved.\r\n   */\n\n\n  this.deleteComment = function (opts, callback) {\n    var options = {\n      uri: this.jiraClient.buildURL('/issue/' + (opts.issueId || opts.issueKey) + '/comment/' + opts.commentId),\n      method: 'DELETE',\n      json: true,\n      followAllRedirects: true\n    };\n    return this.jiraClient.makeRequest(options, callback, 'Comment Deleted');\n  };\n  /**\r\n   * Returns the meta data for editing an issue.\r\n   *\r\n   * The fields in the editmeta correspond to the fields in the edit screen for the issue. Fields not in the screen\r\n   * will not be in the editemeta.\r\n   *\r\n   * @method getEditMetadata\r\n   * @memberof IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *        issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param [callback] Called when the metadata is retrieved.\r\n   * @return {Promise} Resolved when the metadata is retrieved.\r\n   */\n\n\n  this.getEditMetadata = function (opts, callback) {\n    var options = this.buildRequestOptions(opts, '/editmeta', 'GET');\n    return this.jiraClient.makeRequest(options, callback);\n  };\n  /**\r\n   * Sends a notification (email) to the list or recipients defined in the request.\r\n   * A couple of notes: this may call back with the error 'No recipients were defined for notification.' if all\r\n   * of the intended recipients have disabled notifications from Jira.\r\n   *\r\n   * @method sendEmailNotification\r\n   * @memberof IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *        issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {Object} opts.notification See {@link https://docs.atlassian.com/jira/REST/latest/#d2e435}\r\n   * @param [callback] Called when the metadata is retrieved.\r\n   * @return {Promise} Resolved when the metadata is retrieved.\r\n   */\n\n\n  this.sendEmailNotification = function (opts, callback) {\n    if (!opts.notification) {\n      throw new Error(errorStrings.NO_NOTIFICATION_ERROR);\n    }\n\n    var options = this.buildRequestOptions(opts, '/notify', 'POST', opts.notification);\n    return this.jiraClient.makeRequest(options, callback, 'Notifications Sent');\n  };\n  /**\r\n   * Get a REST sub-resource representing the remote issue links on the issue.\r\n   *\r\n   * @method getRemoteLinks\r\n   * @memberof IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *     issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {string} opts.globalId The id of the remote issue link to be returned. If null (not provided) all remote\r\n   *     links for the issue are returned. For a full explanation of Issue Link fields please refer to\r\n   *     {@link https://developer.atlassian.com/display/JIRADEV/Fields+in+Remote+Issue+Links}\r\n   * @param [callback] Called when the remote links are retrieved.\r\n   * @return {Promise} Resolved when the remote links are retrieved.\r\n   */\n\n\n  this.getRemoteLinks = function (opts, callback) {\n    var options = this.buildRequestOptions(opts, '/remotelink', 'GET', null, {\n      globalId: opts.globalId\n    });\n    return this.jiraClient.makeRequest(options, callback);\n  };\n  /**\r\n   * Creates (or updates) a remote issue link from a JSON representation. If a globalId is provided and a remote issue\r\n   * link exists with that globalId, the remote issue link is updated. Otherwise, the remote issue link is created.\r\n   *\r\n   * @method createRemoteLink\r\n   * @memberof IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *     issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {Object} opts.remoteLink See {@link https://docs.atlassian.com/jira/REST/latest/#d2e945}\r\n   * @param [callback] Called when the remote links are retrieved.\r\n   * @return {Promise} Resolved when the remote links are retrieved.\r\n   */\n\n\n  this.createRemoteLink = function (opts, callback) {\n    var options = this.buildRequestOptions(opts, '/remotelink', 'POST', opts.remoteLink);\n    return this.jiraClient.makeRequest(options, callback);\n  };\n  /**\r\n   * Updates (or creates) a remote issue link from a JSON representation. If a globalId is provided and a remote issue\r\n   * link exists with that globalId, the remote issue link is updated. Otherwise, the remote issue link is created.\r\n   *\r\n   * @method updateRemoteLink\r\n   * @memberof IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *     issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {Object} opts.remoteLink See {@link https://docs.atlassian.com/jira/REST/latest/#d2e945}\r\n   * @param [callback] Called when the remote links are retrieved.\r\n   * @return {Promise} Resolved when the remote links are retrieved.\r\n   */\n\n\n  this.updateRemoteLink = function (opts, callback) {\n    // The one API endpoint handles both updates and creation.\n    this.createRemoteLink(opts, callback);\n  };\n  /**\r\n   * Delete the remote issue link with the given global id on the issue.\r\n   *\r\n   * @method deleteRemoteLink\r\n   * @memberof IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *     issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {string} opts.globalId The global id of the remote issue link\r\n   * @param [callback] Called when the remote links are retrieved.\r\n   * @return {Promise} Resolved when the remote links are retrieved.\r\n   */\n\n\n  this.deleteRemoteLink = function (opts, callback) {\n    if (!opts.globalId) {\n      throw new Error(errorStrings.NO_GLOBAL_ID_ERROR);\n    }\n\n    var options = this.buildRequestOptions(opts, '/remotelink', 'DELETE', null, {\n      globalId: opts.globalId\n    });\n    return this.jiraClient.makeRequest(options, callback, 'RemoteLink Deleted');\n  };\n  /**\r\n   * Get the remote issue link with the given id on the issue.\r\n   *\r\n   * @method getRemoteLinkById\r\n   * @memberof IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *     issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {string} opts.linkId The id of the remote link\r\n   * @param [callback] Called when the remote links are retrieved.\r\n   * @return {Promise} Resolved when the remote links are retrieved.\r\n   */\n\n\n  this.getRemoteLinkById = function (opts, callback) {\n    if (!opts.linkId) {\n      throw new Error(errorStrings.NO_LINK_ID_ERROR);\n    }\n\n    var options = this.buildRequestOptions(opts, '/remotelink/' + opts.linkId, 'GET');\n    return this.jiraClient.makeRequest(options, callback);\n  };\n  /**\r\n   * Get the remote issue link with the given id on the issue.\r\n   *\r\n   * @method updateRemoteLinkById\r\n   * @memberof IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *     issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {string} opts.linkId The id of the remote link\r\n   * @param {string} opts.remoteLink See {@link https://docs.atlassian.com/jira/REST/latest/#d2e1037}\r\n   * @param [callback] Called when the remote links are retrieved.\r\n   * @return {Promise} Resolved when the remote links are retrieved.\r\n   */\n\n\n  this.updateRemoteLinkById = function (opts, callback) {\n    if (!opts.linkId) {\n      throw new Error(errorStrings.NO_LINK_ID_ERROR);\n    }\n\n    var options = this.buildRequestOptions(opts, '/remotelink/' + opts.linkId, 'PUT', opts.remoteLink);\n    return this.jiraClient.makeRequest(options, callback, 'RemoteLink Updated');\n  };\n  /**\r\n   * Get the remote issue link with the given id on the issue.\r\n   *\r\n   * @method deleteRemoteLinkById\r\n   * @memberof IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *     issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {string} opts.linkId The id of the remote link\r\n   * @param [callback] Called when the remote links are retrieved.\r\n   * @return {Promise} Resolved when the remote links are retrieved.\r\n   */\n\n\n  this.deleteRemoteLinkById = function (opts, callback) {\n    if (!opts.linkId) {\n      throw new Error(errorStrings.NO_LINK_ID_ERROR);\n    }\n\n    var options = this.buildRequestOptions(opts, '/remotelink/' + opts.linkId, 'DELETE');\n    return this.jiraClient.makeRequest(options, callback, 'RemoteLink Deleted');\n  };\n  /**\r\n   * Get a list of the transitions possible for this issue by the current user, along with fields that are required\r\n   * and their types.\r\n   *\r\n   * Fields will only be returned if ```expand=transitions.fields.```\r\n   *\r\n   * The fields in the metadata correspond to the fields in the transition screen for that transition. Fields not in\r\n   * the screen will not be in the metadata.\r\n   *\r\n   * @method getTransitions\r\n   * @memberof IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *     issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {string} opts.transitionId If specified, will call back with only the transition with the specified id.\r\n   * @param [callback] Called when the transitions are retrieved.\r\n   * @return {Promise} Resolved when the transitions are retrieved.\r\n   */\n\n\n  this.getTransitions = function (opts, callback) {\n    var options = this.buildRequestOptions(opts, '/transitions', 'GET', null, {\n      transitionId: opts.transitionId\n    });\n    return this.jiraClient.makeRequest(options, callback);\n  };\n  /**\r\n   * Perform a transition on an issue. When performing the transition you can udate or set other issue fields.\r\n   *\r\n   * The fields that can be set on transtion, in either the fields parameter or the update parameter can be\r\n   * determined using the** /rest/api/2/issue/{issueIdOrKey}/transitions?expand=transitions.fields resource**. If a\r\n   * field is not configured to appear on the transition screen, then it will not be in the transition metadata, and\r\n   * a field validation error will occur if it is submitted.\r\n   *\r\n   * @method transitionIssue\r\n   * @memberof IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *     issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {object} [opts.transition] See {@link https://docs.atlassian.com/jira/REST/latest/#d2e698}\r\n   * @param {string} [opts.transition.id] The ID of the issue transition. Required when specifying a transition to undertake. \r\n   * @param [callback] Called when the transitions are retrieved.\r\n   * @return {Promise} Resolved when the transitions are retrieved.\r\n   */\n\n\n  this.transitionIssue = function (opts, callback) {\n    var options;\n\n    if (!opts.transition.transition) {\n      // To keep backwards compatibility\n      options = this.buildRequestOptions(opts, '/transitions', 'POST', opts);\n    } else {\n      options = this.buildRequestOptions(opts, '/transitions', 'POST', opts.transition);\n    }\n\n    return this.jiraClient.makeRequest(options, callback, 'Issue Transitioned');\n  };\n  /**\r\n   * Remove your vote from an issue. (i.e. \"unvote\")\r\n   *\r\n   * @method unvote\r\n   * @memberof IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *     issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param [callback] Called after the vote is removed.\r\n   * @return {Promise} Resolved after the vote is removed.\r\n   */\n\n\n  this.unvote = function (opts, callback) {\n    var options = this.buildRequestOptions(opts, '/votes', 'DELETE');\n    return this.jiraClient.makeRequest(options, callback, 'Vote Removed');\n  };\n  /**\r\n   * Cast your vote in favour of an issue.\r\n   *\r\n   * @method vote\r\n   * @memberof IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *     issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param [callback] Called after the vote is removed.\r\n   * @return {Promise} Resolved after the vote is removed.\r\n   */\n\n\n  this.vote = function (opts, callback) {\n    var options = this.buildRequestOptions(opts, '/votes', 'POST');\n    return this.jiraClient.makeRequest(options, callback, 'Vote Added');\n  };\n  /**\r\n   * Get a REST sub-resource representing the voters on the issue.\r\n   *\r\n   * @method getVotes\r\n   * @memberof IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *     issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param [callback] Called after the votes are retrieved.\r\n   * @return {Promise} Resolved after the votes are retrieved.\r\n   */\n\n\n  this.getVotes = function (opts, callback) {\n    var options = this.buildRequestOptions(opts, '/votes', 'GET');\n    return this.jiraClient.makeRequest(options, callback);\n  };\n  /**\r\n   * Returns the list of changelogs for the issue with the given key.\r\n   *\r\n   * @method getChangelog\r\n   * @memberOf IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *     issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {string} [opts.startAt] Pagination startAt (default 0)\r\n   * @param {string} [opts.maxResults] Pagination maxResults (default 100)\r\n   * @param [callback] Called after the changelog is retrieved.\r\n   * @return {Promise} Resolved after the changelog is retrieved.\r\n   */\n\n\n  this.getChangelog = function (opts, callback) {\n    var endpoint = '/issue/' + (opts.issueId || opts.issueKey) + '/changelog';\n    var options = {\n      uri: this.jiraClient.buildURL(endpoint),\n      method: 'GET',\n      json: true,\n      followAllRedirects: true,\n      qs: {\n        startAt: opts.startAt,\n        maxResults: opts.maxResults\n      }\n    };\n    return this.jiraClient.makeRequest(options, callback);\n  };\n  /**\r\n   * Returns the list of watchers for the issue with the given key.\r\n   *\r\n   * @method getWatchers\r\n   * @memberOf IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *     issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param [callback] Called after the watchers are retrieved.\r\n   * @return {Promise} Resolved after the watchers are retrieved.\r\n   */\n\n\n  this.getWatchers = function (opts, callback) {\n    var options = this.buildRequestOptions(opts, '/watchers', 'GET');\n    return this.jiraClient.makeRequest(options, callback);\n  };\n  /**\r\n   * Adds a user to an issue's watcher list.\r\n   *\r\n   * @method addWatcher\r\n   * @memberOf IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *     issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {string} opts.watcher The username of the user to add as a watcher.\r\n   * @param [callback] Called after the watcher is added.\r\n   * @return {Promise} Resolved after the watcher is added.\r\n   */\n\n\n  this.addWatcher = function (opts, callback) {\n    if (!opts.watcher) {\n      throw new Error(errorStrings.NO_WATCHER_ERROR);\n    }\n\n    var options = this.buildRequestOptions(opts, '/watchers', 'POST', opts.watcher);\n    return this.jiraClient.makeRequest(options, callback, 'Watcher Added');\n  };\n  /**\r\n   * Adds a user to an issue's watcher list.\r\n   *\r\n   * @method removeWatcher\r\n   * @memberOf IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *     issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {string} opts.watcher The username of the user to remove as a watcher.\r\n   * @param [callback] Called after the watcher is removed.\r\n   * @return {Promise} Resolved after the watcher is removed.\r\n   */\n\n\n  this.removeWatcher = function (opts, callback) {\n    if (!opts.watcher) {\n      throw new Error(errorStrings.NO_WATCHER_ERROR);\n    }\n\n    var options = this.buildRequestOptions(opts, '/watchers', 'DELETE', null, {\n      username: opts.watcher\n    });\n    return this.jiraClient.makeRequest(options, callback, 'Watcher Removed');\n  };\n  /**\r\n   * Gets all work logs for an issue.\r\n   *\r\n   * @method getWorkLogs\r\n   * @memberOf IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *     issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param [callback] Called after the worklogs are retrieved.\r\n   * @return {Promise} Resolved after the worklogs are retrieved.\r\n   */\n\n\n  this.getWorkLogs = function (opts, callback) {\n    var options = this.buildRequestOptions(opts, '/worklog', 'GET');\n    return this.jiraClient.makeRequest(options, callback);\n  };\n  /**\r\n   * Adds a new worklog entry to an issue.\r\n   *\r\n   * @method addWorkLog\r\n   * @memberOf IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *     issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {string} [opts.adjustEstimate] Allows you to provide specific instructions to update the remaining time\r\n   *     estimate of the issue. Valid values are\r\n   *     * \"new\" - sets the estimate to a specific value\r\n   *     * \"leave\"- leaves the estimate as is\r\n   *     * \"manual\" - specify a specific amount to increase remaining estimate by\r\n   *     * \"auto\"- Default option. Will automatically adjust the value based on the\r\n   *          new timeSpent specified on the worklog\r\n   * @param {string} [opts.newEstimate] (required when \"new\" is selected for adjustEstimate) the new value for the\r\n   *     remaining estimate field. e.g. \"2d\"\r\n   * @param {string} [opts.reduceBy] (required when \"manual\" is selected for adjustEstimate) the amount to reduce the\r\n   *     remaining estimate by e.g. \"2d\"\r\n   * @param [callback] Called after the worklog is added.\r\n   * @return {Promise} Resolved after the worklog is added.\r\n   */\n\n\n  this.addWorkLog = function (opts, callback) {\n    var options = {\n      uri: this.jiraClient.buildURL('/issue/' + (opts.issueId || opts.issueKey) + '/worklog'),\n      method: 'POST',\n      json: true,\n      followAllRedirects: true,\n      qs: {\n        notifyUsers: opts.notifyUsers,\n        adjustEstimate: opts.adjustEstimate,\n        newEstimate: opts.newEstimate,\n        reduceBy: opts.reduceBy,\n        expand: opts.expand,\n        overrideEditableFlag: opts.overrideEditableFlag\n      },\n      body: opts.worklog || Object.assign(opts, {\n        issueId: undefined,\n        issueKey: undefined,\n        notifyUsers: undefined,\n        adjustEstimate: undefined,\n        newEstimate: undefined,\n        reduceBy: undefined,\n        expand: undefined,\n        overrideEditableFlag: undefined\n      })\n    };\n    return this.jiraClient.makeRequest(options, callback, 'Worklog Added');\n  };\n  /**\r\n   * Gets a specific worklog.\r\n   *\r\n   * @method getWorkLog\r\n   * @memberOf IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *     issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {string} opts.id The id of the work log to retrieve.\r\n   * @param [callback] Called after the worklog is retrieved.\r\n   * @return {Promise} Resolved after the worklog is retrieved.\r\n   */\n\n\n  this.getWorkLog = function (opts, callback) {\n    var options = {\n      uri: this.jiraClient.buildURL('/issue/' + (opts.issueId || opts.issueKey) + '/worklog/' + (opts.id || opts.worklogId)),\n      method: 'GET',\n      json: true,\n      followAllRedirects: true,\n      qs: {\n        expand: opts.expand\n      }\n    };\n    return this.jiraClient.makeRequest(options, callback);\n  };\n  /**\r\n   * Updates an existing worklog entry using its JSON representation.\r\n   *\r\n   * @method updateWorkLog\r\n   * @memberOf IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *     issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {string} opts.id The id of the work log to retrieve.\r\n   * @param {string} [opts.adjustEstimate] Allows you to provide specific instructions to update the remaining time\r\n   *     estimate of the issue. Valid values are\r\n   *     * \"new\" - sets the estimate to a specific value\r\n   *     * \"leave\"- leaves the estimate as is\r\n   *     * \"auto\"- Default option. Will automatically adjust the value based on the\r\n   *          new timeSpent specified on the worklog\r\n   * @param {string} [opts.newEstimate] (required when \"new\" is selected for adjustEstimate) the new value for the\r\n   *     remaining estimate field. e.g. \"2d\"\r\n   * @param {Object} opts.worklog See {@link: https://docs.atlassian.com/jira/REST/latest/#d2e1161}\r\n   * @param [callback] Called after the worklog is updated.\r\n   * @return {Promise} Resolved after the worklog is updated.\r\n   */\n\n\n  this.updateWorkLog = function (opts, callback) {\n    var options = {\n      uri: this.jiraClient.buildURL('/issue/' + (opts.issueId || opts.issueKey) + '/worklog/' + (opts.id || opts.worklogId)),\n      method: 'PUT',\n      json: true,\n      followAllRedirects: true,\n      qs: {\n        notifyUsers: opts.notifyUsers,\n        adjustEstimate: opts.adjustEstimate,\n        newEstimate: opts.newEstimate,\n        expand: opts.expand,\n        overrideEditableFlag: opts.overrideEditableFlag\n      },\n      body: Object.assign(opts, {\n        issueId: undefined,\n        issueKey: undefined,\n        notifyUsers: undefined,\n        adjustEstimate: undefined,\n        newEstimate: undefined,\n        expand: undefined,\n        overrideEditableFlag: undefined\n      })\n    };\n    return this.jiraClient.makeRequest(options, callback);\n  };\n  /**\r\n   * Deletes an existing worklog entry\r\n   *\r\n   * @method deleteWorkLog\r\n   * @memberOf IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *     issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {string} opts.id The id of the work log to delete.\r\n   * @param {string} [opts.adjustEstimate] Allows you to provide specific instructions to update the remaining time\r\n   *     estimate of the issue. Valid values are\r\n   *     * \"new\" - sets the estimate to a specific value\r\n   *     * \"leave\"- leaves the estimate as is\r\n   *     * \"manual\" - specify a specific amount to increase remaining estimate by\r\n   *     * \"auto\"- Default option. Will automatically adjust the value based on the\r\n   *          new timeSpent specified on the worklog\r\n   * @param {string} [opts.newEstimate] (required when \"new\" is selected for adjustEstimate) the new value for the\r\n   *     remaining estimate field. e.g. \"2d\"\r\n   * @param {string} [opts.increaseBy] (required when \"manual\" is selected for adjustEstimate) the amount to reduce\r\n   *     the remaining estimate by e.g. \"2d\"\r\n   * @param [callback] Called after the work log is deleted.\r\n   * @return {Promise} Resolved after the work log is deleted.\r\n   */\n\n\n  this.deleteWorkLog = function (opts, callback) {\n    var options = {\n      uri: this.jiraClient.buildURL('/issue/' + (opts.issueId || opts.issueKey) + '/worklog/' + (opts.id || opts.worklogId)),\n      method: 'DELETE',\n      json: true,\n      followAllRedirects: true,\n      qs: {\n        notifyUsers: opts.notifyUsers,\n        adjustEstimate: opts.adjustEstimate,\n        newEstimate: opts.newEstimate,\n        increaseBy: opts.increaseBy,\n        overrideEditableFlag: opts.overrideEditableFlag\n      }\n    };\n    return this.jiraClient.makeRequest(options, callback, 'Work Log Deleted');\n  };\n  /**\r\n   * Add an attachments to an issue.\r\n   *\r\n   * @method addAttachment\r\n   * @memberOf IssueClient\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *     issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {string | Array<string>} opts.filename The file name of attachment. If you pass an array of filenames, multiple attachments will be added.\r\n   * @param {Object} [opts.headers]\r\n   * @param {Function} [callback] Called when the attachment has been attached.\r\n   * @return {Promise} Resolved when the attachment has been attached.\r\n   */\n\n\n  this.addAttachment = function (opts, callback) {\n    var filename = Array.isArray(opts.filename) ? opts.filename : [opts.filename];\n    var attachments = filename.map(function (filePath) {\n      var filename = filePath.split('/').reverse()[0];\n      var mimeType = mime.lookup(filename);\n      return {\n        value: fs.createReadStream(filePath),\n        options: {\n          filename: filename,\n          contentType: mimeType\n        }\n      };\n    });\n    var headers = {\n      charset: 'utf-8',\n      'X-Atlassian-Token': 'nocheck'\n    };\n    var options = {\n      uri: this.jiraClient.buildURL('/issue/' + (opts.issueId || opts.issueKey) + '/attachments'),\n      method: 'POST',\n      json: true,\n      followAllRedirects: true,\n      headers: Object.assign(headers, opts.headers || {}),\n      formData: {\n        file: attachments\n      }\n    };\n    return this.jiraClient.makeRequest(options, callback);\n  };\n  /**\r\n   * Returns the keys of all properties for the issue identified by the key or by the id.  This function is maked as\r\n   * experimental in the Jira API docs, use at your own risk.\r\n   *\r\n   * @method getProperties\r\n   * @memberOf IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *     issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param [callback] Called when the properties are retrieved.\r\n   * @return {Promise} Resolved when the properties are retrieved.\r\n   */\n\n\n  this.getProperties = function (opts, callback) {\n    var options = this.buildRequestOptions(opts, '/properties', 'GET');\n    return this.jiraClient.makeRequest(options, callback);\n  };\n  /**\r\n   * Sets the value of the specified issue's property. You can use this resource to store a custom data against the\r\n   * issue identified by the key or by the id. The user who stores the data is required to have permissions to edit\r\n   * the issue.\r\n   *\r\n   * This function is maked as experimental in the Jira API docs, use at your own risk.\r\n   *\r\n   * @method setProperty\r\n   * @memberOf IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *     issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {string} opts.propertyKey The key of the property being set.\r\n   * @param {Object} opts.propertyValue The value of the property being set.\r\n   * @param [callback] Called when the property is set.\r\n   * @return {Promise} Resolved when the property is set.\r\n   */\n\n\n  this.setProperty = function (opts, callback) {\n    if (!opts.propertyKey) {\n      throw new Error(errorStrings.NO_PROPERTY_KEY_ERROR);\n    } else if (!opts.propertyValue) {\n      throw new Error(errorStrings.NO_PROPERTY_VALUE_ERROR);\n    }\n\n    var options = this.buildRequestOptions(opts, '/properties/' + opts.propertyKey, 'PUT', opts.propertyValue);\n    return this.jiraClient.makeRequest(options, callback, 'Property Set');\n  };\n  /**\r\n   * Returns the value of the property with a given key from the issue identified by the key or by the id. The user\r\n   * who retrieves the property is required to have permissions to read the issue.\r\n   *\r\n   * This function is maked as experimental in the Jira API docs, use at your own risk.\r\n   *\r\n   * @method getProperty\r\n   * @memberOf IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *     issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {string} opts.propertyKey The key of the property being set.\r\n   * @param [callback] Called when the property is retrieved.\r\n   * @return {Promise} Resolved when the property is retrieved.\r\n   */\n\n\n  this.getProperty = function (opts, callback) {\n    if (!opts.propertyKey) {\n      throw new Error(errorStrings.NO_PROPERTY_KEY_ERROR);\n    }\n\n    var options = this.buildRequestOptions(opts, '/properties/' + opts.propertyKey, 'GET');\n    return this.jiraClient.makeRequest(options, callback);\n  };\n  /**\r\n   * Removes the property from the issue identified by the key or by the id. Ths user removing the property is\r\n   * required to have permissions to edit the issue.\r\n   *\r\n   * This function is maked as experimental in the Jira API docs, use at your own risk.\r\n   *\r\n   * @method getProperty\r\n   * @memberOf IssueClient#\r\n   * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\r\n   *     issueKey property; issueId will be used over issueKey if both are present.\r\n   * @param {string} [opts.issueId] The id of the issue.  EX: 10002\r\n   * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\r\n   * @param {string} opts.propertyKey The key of the property being set.\r\n   * @param [callback] Called when the property is deleted.\r\n   * @return {Promise} Resolved when the property is deleted.\r\n   */\n\n\n  this.deleteProperty = function (opts, callback) {\n    if (!opts.propertyKey) {\n      throw new Error(errorStrings.NO_PROPERTY_KEY_ERROR);\n    }\n\n    var options = this.buildRequestOptions(opts, '/properties/' + opts.propertyKey, 'DELETE');\n    return this.jiraClient.makeRequest(options, callback, 'Property Deleted');\n  };\n\n  this.setWorklogProperty = function (opts, callback) {\n    if (!opts.propertyKey) {\n      throw new Error(errorStrings.NO_PROPERTY_KEY_ERROR);\n    } else if (!opts.propertyValue) {\n      throw new Error(errorStrings.NO_PROPERTY_VALUE_ERROR);\n    }\n\n    var options = this.buildRequestOptions(opts, '/worklog/' + opts.worklogId + '/properties/' + opts.propertyKey, 'PUT', opts.propertyValue);\n    return this.jiraClient.makeRequest(options, callback, 'Property Set');\n  };\n\n  this.getWorkLogProperties = function (opts, callback) {\n    var options = this.buildRequestOptions(opts, '/worklog/' + opts.worklogId + '/properties/', 'GET');\n    return this.jiraClient.makeRequest(options, callback);\n  };\n\n  this.getWorkLogProperty = function (opts, callback) {\n    if (!opts.propertyKey) {\n      throw new Error(errorStrings.NO_PROPERTY_KEY_ERROR);\n    }\n\n    var options = this.buildRequestOptions(opts, '/worklog/' + opts.worklogId + '/properties/' + opts.propertyKey, 'GET');\n    return this.jiraClient.makeRequest(options, callback);\n  };\n  /**\r\n   * Build out the request options necessary to make a particular API call.\r\n   *\r\n   * @private\r\n   * @method buildRequestOptions\r\n   * @param {Object} opts The arguments passed to the method.\r\n   * @param {string} path The path of the endpoint following /issue/{idOrKey}\r\n   * @param {string} method The request method.\r\n   * @param {Object} [body] The request body, if any.\r\n   * @param {Object} [qs] The querystring, if any.  opts.expand and opts.fields arrays will be automagically added.\r\n   * @returns {{uri: string, method: string, body: Object, qs: Object, followAllRedirects: boolean, json: boolean}}\r\n   */\n\n\n  this.buildRequestOptions = function (opts, path, method, body, qs) {\n    if (!opts.issueId && !opts.issueKey) {\n      throw new Error(errorStrings.NO_ISSUE_IDENTIFIER);\n    }\n\n    var idOrKey = opts.issueId || opts.issueKey;\n    var basePath = '/issue/' + idOrKey;\n    if (!qs) qs = {};\n    if (!body) body = {};\n\n    if (opts.fields) {\n      qs.fields = '';\n      opts.fields.forEach(function (field) {\n        qs.fields += field + ',';\n      });\n    }\n\n    if (opts.expand) {\n      qs.expand = '';\n      opts.expand.forEach(function (ex) {\n        qs.expand += ex + ',';\n      });\n    }\n\n    if (opts.properties) {\n      qs.properties = '';\n      opts.properties.forEach(function (prop) {\n        qs.properties += prop + ',';\n      });\n    }\n\n    return {\n      uri: this.jiraClient.buildURL(basePath + path),\n      method: method,\n      body: body,\n      qs: qs,\n      followAllRedirects: true,\n      json: true\n    };\n  };\n  /**\r\n   * Returns suggested issues which match the auto-completion query for the \r\n   * user which executes this request. This REST method will check the user's \r\n   * history and the user's browsing context and select this issues, which \r\n   * match the query.\r\n   *\r\n   * @method getIssuePicker\r\n   * @memberOf IssueClient#\r\n   * @param {Object} opts The options to pass to the API.\r\n   * @param {string} [opts.query] the query\r\n   * @param {string} [opts.currentJQL] the JQL in context of which the request \r\n   *                 is executed. Only issues which match this JQL query will be \r\n   *                 included in results.\r\n   * @param {string} [opts.currentIssueKey] the key of the issue in context of \r\n   *                 which the request is executed. The issue which is in context \r\n   *                 will not be included in the auto-completion result, even if \r\n   *                 it matches the query.\r\n   * @param {string} [opts.currentProjectId] the id of the project in context of \r\n   *                 which the request is executed. Suggested issues will be only \r\n   *                 from this project.\r\n   * @param {boolean} [opts.showSubTasks] if set to false, subtasks will not be \r\n   *                  included in the list.\r\n   * @param {boolean} [opts.showSubTaskParent] if set to false and request is \r\n   *                  executed in context of a subtask, the parent issue will \r\n   *                  not be included in the auto-completion result, even if it \r\n   *                  matches the query.\r\n   * @param [callback] Called when the issues have been retrieved.\r\n   * @return {Promise} Resolved when the issues have been retrieved.\r\n   */\n\n\n  this.getIssuePicker = function (opts, callback) {\n    var options = {\n      uri: this.jiraClient.buildURL('/issue/picker'),\n      method: 'GET',\n      json: true,\n      followAllRedirects: true,\n      qs: {\n        query: opts.query,\n        currentJQL: opts.currentJQL,\n        currentIssueKey: opts.currentIssueKey,\n        currentProjectId: opts.currentProjectId,\n        showSubTasks: opts.showSubTasks,\n        showSubTaskParent: opts.showSubTaskParent\n      }\n    };\n    return this.jiraClient.makeRequest(options, callback);\n  };\n}","map":null,"metadata":{},"sourceType":"script"}